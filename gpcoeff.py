# -*- coding: utf-8 -*-
"""GPCoeff.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ajzeJ-D1-j5ZfrHGyCVrKU-_I1scMIp2
"""

from sympy import *
import scipy as sc
import random
import numpy as np

class GpCoeffOptimizer:
  def __init__(self, expr = None, populationSize = 100, 
               generations = 100,
               crossoverProbability = 0.8,
               mutationProbability = 0.2,
               elitePercentage = 0.1,
               selectionPercentage = 0.2,
               inputs = [], coeffs = [], inputData = [], targetData = [], 
               verbose = False):
    self.inputs = inputs
    self.coeffs = coeffs
    self.inputData = inputData
    self.targetData = targetData  
    self.verbose = verbose
    self.limit = generations
    self.randomMaxValue = 2 # Max abosolute value allowed when creating random value
    self.currentGeneration = [] # should contain (loss, [coefficients])
    self.maxPopulationSize = populationSize
    self.expr = expr
    self.f = lambdify([self.inputs+self.coeffs], expr, modules = ["numpy",{'Heaviside':myH}])
    self.elite_percentage = elitePercentage
    self.generation_number = 0
    self.selection_size = max(2, floor(selectionPercentage*populationSize))
    self.mutation_probability = mutationProbability
    self.crossover_probability = crossoverProbability

  def loadData(self, inputData = [], targetData = []):
    if inputData:
      self.inputData = inputData
    if targetData:
      self.targetData = targetData

  def normalizeTargetData(self):
    targetData = targetData/max(targetData)

  def loss(self, coeffValues):
    if len(self.inputData) == 0:
      print("No data fed")
      return float ('inf')
    if len(self.inputData) != len(self.targetData):
      print("input number and target number not match")
    if self.inputData.shape[1] != len(self.inputs):
      print(self.inputData.shape, len(self.inputs))
      print("Bad data fed")
      return float("inf")

    dataToFeed = self.inputData

    for value in coeffValues:
      new_column = np.full((len(self.inputData),1), value)
      dataToFeed = np.append(dataToFeed, new_column, axis=1)
    dataToFeed = np.transpose(dataToFeed)

    return sum((self.f(dataToFeed) - self.targetData)**2)/self.inputData.shape[0]

  def create_individual(self):
    return self.randomMaxValue*(np.random.rand(1,len(self.coeffs)) - 1)[0]

  def create_initial_population(self):
    while len(self.currentGeneration) < self.maxPopulationSize:
      newCoeffs = self.create_individual()
      loss = self.loss(newCoeffs)
      self.currentGeneration.append((loss, newCoeffs))

    self.currentGeneration.sort()

  def crossover(self,parent_1_gene, parent_2_gene):
    index = random.randrange(1,len(parent_1_gene))
    child_1_gene = np.append(parent_1_gene[:index], parent_2_gene[index:])
    child_2_gene = np.append(parent_2_gene[:index], parent_1_gene[index:])
    return child_1_gene, child_2_gene
  
  def mutate(self, individual_gene):
    index = random.randrange(0,len(individual_gene))
    individual_gene[index] = random.uniform(-self.randomMaxValue,self.randomMaxValue)
    return individual_gene

  def selection(self, start):
    participants = random.sample(self.currentGeneration[start:], self.selection_size)
    return min(participants, key = lambda x: x[0])

  def create_new_generation(self):
    preservedTill = floor(len(self.currentGeneration) * self.elite_percentage)
    new_generation = self.currentGeneration[:preservedTill]

    while len(new_generation) < self.maxPopulationSize:
      parent_1_gene = self.selection(preservedTill)[1]
      parent_2_gene = self.selection(preservedTill)[1]

      child_1_gene, child_2_gene = parent_1_gene, parent_2_gene

      if random.random() < self.crossover_probability:
        child_1_gene, child_2_gene = self.crossover(parent_1_gene, parent_2_gene)

      if random.random() < self.mutation_probability:
        child_1_gene = self.mutate(child_1_gene)
      
      if random.random() < self.mutation_probability:
        child_2_gene = self.mutate(child_2_gene)

      new_generation.append((self.loss(child_1_gene), child_1_gene))
      new_generation.append((self.loss(child_2_gene), child_2_gene))

    self.currentGeneration = sorted(new_generation[:self.maxPopulationSize], key=lambda x:x[0])


  
  def show_last_generation(self):
    print("Current Generations:") 
    print(self.currentGeneration)

  def best_fit(self):
    print("Best fit is:")
    print(self.currentGeneration[0])

  def optimize(self):
    self.create_initial_population()
    while self.generation_number < self.limit:
      self.create_new_generation()
      if self.verbose:
        print("Generation ", self.generation_number + 1, "best offspring: ")
        self.best_fit()
      self.generation_number += 1

"""Sample Usage:
Suppose you have 5 input values: t T x y z
And you have 5 unknown parameters to fit: c0 c1 c2 c3 c4
Use GA (Genetic Algorithm) to find true value of these 5 coefficients
"""

t, T = symbols('t T')
x, y, z = symbols('x y z')
inputs = [t, T,x,y,z]
coeffs = list(symbols('a:5'))

# expr = x*coeffs[0] + t * coeffs[1] + exp(T) - sin(coeffs[2]*y) + coeffs[3] * z + t**coeffs[4] # A normal function
expr = Heaviside(x-coeffs[2])*coeffs[0] + t * coeffs[1] + exp(T) - sin(coeffs[2]*y) + coeffs[3] * z + t**coeffs[4] # A discontinuous function
g = lambdify([[t,T,x,y,z,coeffs[0],coeffs[1],coeffs[2],coeffs[3],coeffs[4]]], expr, modules = ["numpy",{'Heaviside':myH}])

coeffValues = np.array([2,-1,1.5,-1.2,1.4]) # The true values of 5 coefficients
# [ 1.9767    , -1.00483788,  1.49841407, -1.19291297,  1.36187899]

#Generate inputData:
inputData = []
for _ in range(1000):
  #Create random inputs
  input = [random.uniform(0,1), random.uniform(0,3), random.uniform(0,8), random.uniform(0,2), random.uniform(0, 5)]
  # print(input)
  inputData.append(input)

inputData = np.array(inputData)
dataToFeed = inputData

for value in coeffValues:
  # Combine inputs and coeffs so that function g can execute on them
  new_column = np.full((len(dataToFeed),1), value)
  dataToFeed = np.append(dataToFeed, new_column, axis=1)
dataToFeed = np.transpose(dataToFeed)
print(dataToFeed.shape)


targetData = g(dataToFeed)
#print(targetData)
#print(targetData.shape)

Optimizer1 = GpCoeffOptimizer(expr, 50,1000,0.8,0.3,0.02,0.4,inputs=inputs, coeffs=coeffs, inputData = inputData, targetData = targetData, verbose = True)
# Optimizer1.inputData
Optimizer1.optimize()